// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'book_annotation.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

BookAnnotation _$BookAnnotationFromJson(Map<String, dynamic> json) {
  return _BookAnnotation.fromJson(json);
}

/// @nodoc
mixin _$BookAnnotation {
  String? get annotationId => throw _privateConstructorUsedError;
  String? get annotationType => throw _privateConstructorUsedError;
  String? get annotationDrawType => throw _privateConstructorUsedError;
  String? get ebookId => throw _privateConstructorUsedError;
  String? get endPos => throw _privateConstructorUsedError;
  String? get fileIndex => throw _privateConstructorUsedError;
  String? get highlightColor => throw _privateConstructorUsedError;
  String? get memo => throw _privateConstructorUsedError;
  String? get modifiedTime => throw _privateConstructorUsedError;
  String? get pagePercent => throw _privateConstructorUsedError;
  String? get posType => throw _privateConstructorUsedError;
  String? get sentence => throw _privateConstructorUsedError;
  String? get startPos => throw _privateConstructorUsedError;
  String? get statusCd => throw _privateConstructorUsedError;
  String? get xpathEnd => throw _privateConstructorUsedError;
  String? get xpathOffsetEnd => throw _privateConstructorUsedError;
  String? get xpathOffsetStart => throw _privateConstructorUsedError;
  String? get xpathStart => throw _privateConstructorUsedError;
  String? get seq => throw _privateConstructorUsedError;
  int? get managedId => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $BookAnnotationCopyWith<BookAnnotation> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BookAnnotationCopyWith<$Res> {
  factory $BookAnnotationCopyWith(
          BookAnnotation value, $Res Function(BookAnnotation) then) =
      _$BookAnnotationCopyWithImpl<$Res, BookAnnotation>;
  @useResult
  $Res call(
      {String? annotationId,
      String? annotationType,
      String? annotationDrawType,
      String? ebookId,
      String? endPos,
      String? fileIndex,
      String? highlightColor,
      String? memo,
      String? modifiedTime,
      String? pagePercent,
      String? posType,
      String? sentence,
      String? startPos,
      String? statusCd,
      String? xpathEnd,
      String? xpathOffsetEnd,
      String? xpathOffsetStart,
      String? xpathStart,
      String? seq,
      int? managedId});
}

/// @nodoc
class _$BookAnnotationCopyWithImpl<$Res, $Val extends BookAnnotation>
    implements $BookAnnotationCopyWith<$Res> {
  _$BookAnnotationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? annotationId = freezed,
    Object? annotationType = freezed,
    Object? annotationDrawType = freezed,
    Object? ebookId = freezed,
    Object? endPos = freezed,
    Object? fileIndex = freezed,
    Object? highlightColor = freezed,
    Object? memo = freezed,
    Object? modifiedTime = freezed,
    Object? pagePercent = freezed,
    Object? posType = freezed,
    Object? sentence = freezed,
    Object? startPos = freezed,
    Object? statusCd = freezed,
    Object? xpathEnd = freezed,
    Object? xpathOffsetEnd = freezed,
    Object? xpathOffsetStart = freezed,
    Object? xpathStart = freezed,
    Object? seq = freezed,
    Object? managedId = freezed,
  }) {
    return _then(_value.copyWith(
      annotationId: freezed == annotationId
          ? _value.annotationId
          : annotationId // ignore: cast_nullable_to_non_nullable
              as String?,
      annotationType: freezed == annotationType
          ? _value.annotationType
          : annotationType // ignore: cast_nullable_to_non_nullable
              as String?,
      annotationDrawType: freezed == annotationDrawType
          ? _value.annotationDrawType
          : annotationDrawType // ignore: cast_nullable_to_non_nullable
              as String?,
      ebookId: freezed == ebookId
          ? _value.ebookId
          : ebookId // ignore: cast_nullable_to_non_nullable
              as String?,
      endPos: freezed == endPos
          ? _value.endPos
          : endPos // ignore: cast_nullable_to_non_nullable
              as String?,
      fileIndex: freezed == fileIndex
          ? _value.fileIndex
          : fileIndex // ignore: cast_nullable_to_non_nullable
              as String?,
      highlightColor: freezed == highlightColor
          ? _value.highlightColor
          : highlightColor // ignore: cast_nullable_to_non_nullable
              as String?,
      memo: freezed == memo
          ? _value.memo
          : memo // ignore: cast_nullable_to_non_nullable
              as String?,
      modifiedTime: freezed == modifiedTime
          ? _value.modifiedTime
          : modifiedTime // ignore: cast_nullable_to_non_nullable
              as String?,
      pagePercent: freezed == pagePercent
          ? _value.pagePercent
          : pagePercent // ignore: cast_nullable_to_non_nullable
              as String?,
      posType: freezed == posType
          ? _value.posType
          : posType // ignore: cast_nullable_to_non_nullable
              as String?,
      sentence: freezed == sentence
          ? _value.sentence
          : sentence // ignore: cast_nullable_to_non_nullable
              as String?,
      startPos: freezed == startPos
          ? _value.startPos
          : startPos // ignore: cast_nullable_to_non_nullable
              as String?,
      statusCd: freezed == statusCd
          ? _value.statusCd
          : statusCd // ignore: cast_nullable_to_non_nullable
              as String?,
      xpathEnd: freezed == xpathEnd
          ? _value.xpathEnd
          : xpathEnd // ignore: cast_nullable_to_non_nullable
              as String?,
      xpathOffsetEnd: freezed == xpathOffsetEnd
          ? _value.xpathOffsetEnd
          : xpathOffsetEnd // ignore: cast_nullable_to_non_nullable
              as String?,
      xpathOffsetStart: freezed == xpathOffsetStart
          ? _value.xpathOffsetStart
          : xpathOffsetStart // ignore: cast_nullable_to_non_nullable
              as String?,
      xpathStart: freezed == xpathStart
          ? _value.xpathStart
          : xpathStart // ignore: cast_nullable_to_non_nullable
              as String?,
      seq: freezed == seq
          ? _value.seq
          : seq // ignore: cast_nullable_to_non_nullable
              as String?,
      managedId: freezed == managedId
          ? _value.managedId
          : managedId // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$BookAnnotationImplCopyWith<$Res>
    implements $BookAnnotationCopyWith<$Res> {
  factory _$$BookAnnotationImplCopyWith(_$BookAnnotationImpl value,
          $Res Function(_$BookAnnotationImpl) then) =
      __$$BookAnnotationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? annotationId,
      String? annotationType,
      String? annotationDrawType,
      String? ebookId,
      String? endPos,
      String? fileIndex,
      String? highlightColor,
      String? memo,
      String? modifiedTime,
      String? pagePercent,
      String? posType,
      String? sentence,
      String? startPos,
      String? statusCd,
      String? xpathEnd,
      String? xpathOffsetEnd,
      String? xpathOffsetStart,
      String? xpathStart,
      String? seq,
      int? managedId});
}

/// @nodoc
class __$$BookAnnotationImplCopyWithImpl<$Res>
    extends _$BookAnnotationCopyWithImpl<$Res, _$BookAnnotationImpl>
    implements _$$BookAnnotationImplCopyWith<$Res> {
  __$$BookAnnotationImplCopyWithImpl(
      _$BookAnnotationImpl _value, $Res Function(_$BookAnnotationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? annotationId = freezed,
    Object? annotationType = freezed,
    Object? annotationDrawType = freezed,
    Object? ebookId = freezed,
    Object? endPos = freezed,
    Object? fileIndex = freezed,
    Object? highlightColor = freezed,
    Object? memo = freezed,
    Object? modifiedTime = freezed,
    Object? pagePercent = freezed,
    Object? posType = freezed,
    Object? sentence = freezed,
    Object? startPos = freezed,
    Object? statusCd = freezed,
    Object? xpathEnd = freezed,
    Object? xpathOffsetEnd = freezed,
    Object? xpathOffsetStart = freezed,
    Object? xpathStart = freezed,
    Object? seq = freezed,
    Object? managedId = freezed,
  }) {
    return _then(_$BookAnnotationImpl(
      annotationId: freezed == annotationId
          ? _value.annotationId
          : annotationId // ignore: cast_nullable_to_non_nullable
              as String?,
      annotationType: freezed == annotationType
          ? _value.annotationType
          : annotationType // ignore: cast_nullable_to_non_nullable
              as String?,
      annotationDrawType: freezed == annotationDrawType
          ? _value.annotationDrawType
          : annotationDrawType // ignore: cast_nullable_to_non_nullable
              as String?,
      ebookId: freezed == ebookId
          ? _value.ebookId
          : ebookId // ignore: cast_nullable_to_non_nullable
              as String?,
      endPos: freezed == endPos
          ? _value.endPos
          : endPos // ignore: cast_nullable_to_non_nullable
              as String?,
      fileIndex: freezed == fileIndex
          ? _value.fileIndex
          : fileIndex // ignore: cast_nullable_to_non_nullable
              as String?,
      highlightColor: freezed == highlightColor
          ? _value.highlightColor
          : highlightColor // ignore: cast_nullable_to_non_nullable
              as String?,
      memo: freezed == memo
          ? _value.memo
          : memo // ignore: cast_nullable_to_non_nullable
              as String?,
      modifiedTime: freezed == modifiedTime
          ? _value.modifiedTime
          : modifiedTime // ignore: cast_nullable_to_non_nullable
              as String?,
      pagePercent: freezed == pagePercent
          ? _value.pagePercent
          : pagePercent // ignore: cast_nullable_to_non_nullable
              as String?,
      posType: freezed == posType
          ? _value.posType
          : posType // ignore: cast_nullable_to_non_nullable
              as String?,
      sentence: freezed == sentence
          ? _value.sentence
          : sentence // ignore: cast_nullable_to_non_nullable
              as String?,
      startPos: freezed == startPos
          ? _value.startPos
          : startPos // ignore: cast_nullable_to_non_nullable
              as String?,
      statusCd: freezed == statusCd
          ? _value.statusCd
          : statusCd // ignore: cast_nullable_to_non_nullable
              as String?,
      xpathEnd: freezed == xpathEnd
          ? _value.xpathEnd
          : xpathEnd // ignore: cast_nullable_to_non_nullable
              as String?,
      xpathOffsetEnd: freezed == xpathOffsetEnd
          ? _value.xpathOffsetEnd
          : xpathOffsetEnd // ignore: cast_nullable_to_non_nullable
              as String?,
      xpathOffsetStart: freezed == xpathOffsetStart
          ? _value.xpathOffsetStart
          : xpathOffsetStart // ignore: cast_nullable_to_non_nullable
              as String?,
      xpathStart: freezed == xpathStart
          ? _value.xpathStart
          : xpathStart // ignore: cast_nullable_to_non_nullable
              as String?,
      seq: freezed == seq
          ? _value.seq
          : seq // ignore: cast_nullable_to_non_nullable
              as String?,
      managedId: freezed == managedId
          ? _value.managedId
          : managedId // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$BookAnnotationImpl implements _BookAnnotation {
  const _$BookAnnotationImpl(
      {this.annotationId,
      this.annotationType,
      this.annotationDrawType,
      this.ebookId,
      this.endPos,
      this.fileIndex,
      this.highlightColor,
      this.memo,
      this.modifiedTime,
      this.pagePercent,
      this.posType,
      this.sentence,
      this.startPos,
      this.statusCd,
      this.xpathEnd,
      this.xpathOffsetEnd,
      this.xpathOffsetStart,
      this.xpathStart,
      this.seq,
      this.managedId});

  factory _$BookAnnotationImpl.fromJson(Map<String, dynamic> json) =>
      _$$BookAnnotationImplFromJson(json);

  @override
  final String? annotationId;
  @override
  final String? annotationType;
  @override
  final String? annotationDrawType;
  @override
  final String? ebookId;
  @override
  final String? endPos;
  @override
  final String? fileIndex;
  @override
  final String? highlightColor;
  @override
  final String? memo;
  @override
  final String? modifiedTime;
  @override
  final String? pagePercent;
  @override
  final String? posType;
  @override
  final String? sentence;
  @override
  final String? startPos;
  @override
  final String? statusCd;
  @override
  final String? xpathEnd;
  @override
  final String? xpathOffsetEnd;
  @override
  final String? xpathOffsetStart;
  @override
  final String? xpathStart;
  @override
  final String? seq;
  @override
  final int? managedId;

  @override
  String toString() {
    return 'BookAnnotation(annotationId: $annotationId, annotationType: $annotationType, annotationDrawType: $annotationDrawType, ebookId: $ebookId, endPos: $endPos, fileIndex: $fileIndex, highlightColor: $highlightColor, memo: $memo, modifiedTime: $modifiedTime, pagePercent: $pagePercent, posType: $posType, sentence: $sentence, startPos: $startPos, statusCd: $statusCd, xpathEnd: $xpathEnd, xpathOffsetEnd: $xpathOffsetEnd, xpathOffsetStart: $xpathOffsetStart, xpathStart: $xpathStart, seq: $seq, managedId: $managedId)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BookAnnotationImpl &&
            (identical(other.annotationId, annotationId) ||
                other.annotationId == annotationId) &&
            (identical(other.annotationType, annotationType) ||
                other.annotationType == annotationType) &&
            (identical(other.annotationDrawType, annotationDrawType) ||
                other.annotationDrawType == annotationDrawType) &&
            (identical(other.ebookId, ebookId) || other.ebookId == ebookId) &&
            (identical(other.endPos, endPos) || other.endPos == endPos) &&
            (identical(other.fileIndex, fileIndex) ||
                other.fileIndex == fileIndex) &&
            (identical(other.highlightColor, highlightColor) ||
                other.highlightColor == highlightColor) &&
            (identical(other.memo, memo) || other.memo == memo) &&
            (identical(other.modifiedTime, modifiedTime) ||
                other.modifiedTime == modifiedTime) &&
            (identical(other.pagePercent, pagePercent) ||
                other.pagePercent == pagePercent) &&
            (identical(other.posType, posType) || other.posType == posType) &&
            (identical(other.sentence, sentence) ||
                other.sentence == sentence) &&
            (identical(other.startPos, startPos) ||
                other.startPos == startPos) &&
            (identical(other.statusCd, statusCd) ||
                other.statusCd == statusCd) &&
            (identical(other.xpathEnd, xpathEnd) ||
                other.xpathEnd == xpathEnd) &&
            (identical(other.xpathOffsetEnd, xpathOffsetEnd) ||
                other.xpathOffsetEnd == xpathOffsetEnd) &&
            (identical(other.xpathOffsetStart, xpathOffsetStart) ||
                other.xpathOffsetStart == xpathOffsetStart) &&
            (identical(other.xpathStart, xpathStart) ||
                other.xpathStart == xpathStart) &&
            (identical(other.seq, seq) || other.seq == seq) &&
            (identical(other.managedId, managedId) ||
                other.managedId == managedId));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        annotationId,
        annotationType,
        annotationDrawType,
        ebookId,
        endPos,
        fileIndex,
        highlightColor,
        memo,
        modifiedTime,
        pagePercent,
        posType,
        sentence,
        startPos,
        statusCd,
        xpathEnd,
        xpathOffsetEnd,
        xpathOffsetStart,
        xpathStart,
        seq,
        managedId
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BookAnnotationImplCopyWith<_$BookAnnotationImpl> get copyWith =>
      __$$BookAnnotationImplCopyWithImpl<_$BookAnnotationImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$BookAnnotationImplToJson(
      this,
    );
  }
}

abstract class _BookAnnotation implements BookAnnotation {
  const factory _BookAnnotation(
      {final String? annotationId,
      final String? annotationType,
      final String? annotationDrawType,
      final String? ebookId,
      final String? endPos,
      final String? fileIndex,
      final String? highlightColor,
      final String? memo,
      final String? modifiedTime,
      final String? pagePercent,
      final String? posType,
      final String? sentence,
      final String? startPos,
      final String? statusCd,
      final String? xpathEnd,
      final String? xpathOffsetEnd,
      final String? xpathOffsetStart,
      final String? xpathStart,
      final String? seq,
      final int? managedId}) = _$BookAnnotationImpl;

  factory _BookAnnotation.fromJson(Map<String, dynamic> json) =
      _$BookAnnotationImpl.fromJson;

  @override
  String? get annotationId;
  @override
  String? get annotationType;
  @override
  String? get annotationDrawType;
  @override
  String? get ebookId;
  @override
  String? get endPos;
  @override
  String? get fileIndex;
  @override
  String? get highlightColor;
  @override
  String? get memo;
  @override
  String? get modifiedTime;
  @override
  String? get pagePercent;
  @override
  String? get posType;
  @override
  String? get sentence;
  @override
  String? get startPos;
  @override
  String? get statusCd;
  @override
  String? get xpathEnd;
  @override
  String? get xpathOffsetEnd;
  @override
  String? get xpathOffsetStart;
  @override
  String? get xpathStart;
  @override
  String? get seq;
  @override
  int? get managedId;
  @override
  @JsonKey(ignore: true)
  _$$BookAnnotationImplCopyWith<_$BookAnnotationImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
